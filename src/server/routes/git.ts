/**
 * Git Route - PR creation and Git operations
 */

import { Router } from 'express';
import { GitTool } from '../../agent/tools/git-tool';
import { logger } from '../middleware/logger';
import { tasks } from './codegen';

const router = Router();

router.post('/git/create-pr', async (req, res) => {
  try {
    const { taskId, sessionId } = req.body;

    if (!taskId || !sessionId) {
      return res.status(400).json({
        error: 'taskId and sessionId are required',
      });
    }

    // Get task from memory
    const task = tasks.get(taskId);

    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }

    if (task.status !== 'completed') {
      return res.status(400).json({
        error: 'Cannot create PR for incomplete task',
      });
    }

    logger.info(`Creating PR for task ${taskId}`);

    const workingDirectory = task.context?.workingDirectory || process.cwd();
    const gitTool = new GitTool(workingDirectory, true);

    // Create a branch name from the prompt
    const branchName = `mikasa/${taskId}`;

    // Get current branch
    const statusResult = await gitTool.execute({
      operation: 'status',
    });

    if (!statusResult.success) {
      return res.status(500).json({
        error: 'Failed to get git status',
        details: statusResult.error,
      });
    }

    // Create and checkout new branch
    const branchResult = await gitTool.execute({
      operation: 'branch',
      params: { name: branchName, checkout: true },
    });

    if (!branchResult.success) {
      return res.status(500).json({
        error: 'Failed to create branch',
        details: branchResult.error,
      });
    }

    // Stage all changes
    const addResult = await gitTool.execute({
      operation: 'add',
      params: { files: ['.'] },
    });

    if (!addResult.success) {
      return res.status(500).json({
        error: 'Failed to stage changes',
        details: addResult.error,
      });
    }

    // Commit changes
    const commitMessage = `feat: ${task.prompt.substring(0, 80)}

Generated by Mikasa AI
Task ID: ${taskId}
Session ID: ${sessionId}

Changes:
${task.result?.filesModified?.map((f: string) => `- ${f}`).join('\n') || 'Multiple files modified'}
`;

    const commitResult = await gitTool.execute({
      operation: 'commit',
      params: { message: commitMessage },
    });

    if (!commitResult.success) {
      return res.status(500).json({
        error: 'Failed to commit changes',
        details: commitResult.error,
      });
    }

    // Push to remote
    const pushResult = await gitTool.execute({
      operation: 'push',
      params: { branch: branchName, setUpstream: true },
    });

    if (!pushResult.success) {
      return res.status(500).json({
        error: 'Failed to push changes',
        details: pushResult.error,
      });
    }

    // Create PR using GitHub CLI or API
    const prResult = await gitTool.execute({
      operation: 'createPR',
      params: {
        title: task.prompt.substring(0, 100),
        body: `## Summary\n\nGenerated by Mikasa AI\n\n**Prompt:** ${task.prompt}\n\n**Files Modified:**\n${task.result?.filesModified?.map((f: string) => `- ${f}`).join('\n') || 'Multiple files'}\n\n**Task ID:** ${taskId}\n**Session ID:** ${sessionId}`,
        base: 'main',
        head: branchName,
      },
    });

    if (!prResult.success) {
      return res.status(500).json({
        error: 'Failed to create PR',
        details: prResult.error,
      });
    }

    logger.info(`PR created successfully for task ${taskId}`);

    res.json({
      success: true,
      prUrl: prResult.output,
      branch: branchName,
    });
  } catch (error: any) {
    logger.error('Error creating PR:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
